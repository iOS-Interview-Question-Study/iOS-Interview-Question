## 11. HTTP와 HTTPS의 차이점, 그리고 iOS에서의 보안 통신 방법에 대해 설명해주세요.
- SSL/TLS의 동작 원리는 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**HTTP와 HTTPS의 차이점**
- HTTP와 HTTPS는 클라이언트와 서버 간 통신을 위한 통신 규약 입니다.
- HTTP의 패킷은 암호화되어 있지 않아서 외부에서 정보를 확인할 수 있습니다. HTTPS의 경우 패킷이 암호화되어 외부에서는 패킷의 내용을 알 수 없다는 차이가 있습니다.
**iOS에서의 보안 통신 방법**
- App Transport Security (ATS)
	- iOS 9 부터 기본적으로 **HTTPS만 허용**
	- Info.plist에서 ATS를 비활성화 하면 예외적으로 HTTP를 사용할 수 있다.
- SSL/TLS 암호화 적용
	- URLSession을 사용하면 iOS에서 자동으로 TLS 1.2 이상을 적용
	- 보안 강화를 위해 **SSL Pinning**을 사용할 수 있다.
- SSL Pinning (공개키 고정, 인증서 고정)
	- 공격자가 가짜 인증서를 사용해 중간에서 데이터를 탈취하는 Man-In-The-Middle(중간자 공격) 공격을 방지
	- iOS에서 SSL Pinning을 적용하는 방법
		- 앱 내부에 신뢰할 인증서의 **공개키** 저장
		- 서버 인증서의 공개키와 앱 내 저장된 공개키 비교
		- 일치하면 통신 허용, 불일치 시 차단
**SSL/TLS의 동작 원리**
- SSL과 TLS는 사실상 같다고 볼 수 있다. SSL을 업그레이드 한 것이 TLS이기 때문이다. 하지만 현재 SSL은 사용하지 않고 TLS 1.2, 1.3을 사용한다.
1. Handshake 과정
	1. 클라이언트 (iOS 앱) -> 서버: 지원하는 암호화 방식 목록 전달.
	2. 서버 -> 클라이언트: SSL/TLS 인증서 
		- 해당 인증서에는 서버의 신원을 증명하는 정보와 공개키가 포함
	3. 클라이언트 인증서 검증: 신뢰할 수 있는 CA(인증 기관)인지 확인
	4. 암호화 키 생성: 서버와 클라이언트가 세션 키를 교환하고 보안 연결을 확립
2. 데이터 전송 (암호화된 HTTPS 통신 시작)
	1. 이후 모든 데이터는 TLS 암호화 방식으로 암호화되어 전송

</div>
</details>

## 12. 컴퓨터 네트워킹에서 OSI 7계층 모델에 대해 설명해주세요.
- 각 계층의 역할과 프로토콜은 무엇인가요?
- TCP/IP 모델과 OSI 모델의 차이점은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">


**OSI 7계층**
- 응용 계층 (Application Layer)
	- 사용자가 직접 접근하는 계층, 네트워크 서비스 제공
	- **프로토콜**: HTTP, HTTPS, FTP, SMTP, DNS
- 표현 계층 (Presentation Layer)
	- 전송하는 데이터의 표현 방식을 결정 (데이터의 형식 변환, 암호화, 압축 등)
	- 기능: 데이터 인코딩/ 디코딩, 암호화/복호화, 데이터 압축
	- 예시: SSL/TLS 암호화, JPEG, MP4 포맷 변환
- 세션 계층 (Session Layer)
	- 통신의 설정, 유지, 종료를 관리
	- 예시: 로그인 유지 기능, API 세션 관리
- 전송 계층 (Transport Layer)
	- 데이터의 **신뢰성** 있는 전송 보장, 오류 검출 및 복구 처리
	- 프로토콜: TCP (신뢰성 보장), UDP (빠른 속도)
- 네트워크 계층 (Network Layer)
	- 데이터를 목적지까지 **최적의 경로를 찾아 패킷을 전달** (라우팅)
	- **패킷** 단위
	- 프로토콜: IP, ICMP, ARP
	- 해당 장비로는 라우터가 있다.
- 데이터 링크 계층 (DataLink Layer)
	- 프레임 단위로 데이터를 주고받으며, 오류 검출 및 프레임 흐름 제어 수행
	- **프레임** 단위
	- 프로토콜: 이더넷, Wi-Fi
	- 해당 장비로는 이더넷, 브리지, 스위치 등이 있다.
	-> 프레임에 주소 부여(MAC - 물리적 주소), 에러 검출 / 재전송 / 흐름 제어
- 물리 계층 (Physical Layer)
	- 실제 물리적 신호를 담당
	- 0과 1의 **비트** 단위
	- 해당 장비로는 LAN, 광 케이블 등이 있다.
	-> 케이블, 리피터, 허브 등을 통해 데이터를 전송한다.

**TCP/IP 모델**
- 응용 계층 (Application Layer)
	- HTTP, HTTPS, FTP 등 사용자와 직접 접하는 계층
- 전송 계층 (Transport Layer)
	- 데이터의 신뢰성 보장과 흐름 제어 담당
	- 프로토콜: TCP (신뢰성 보장), UDP (빠른 속도)
- 인터넷 계층 (Internet Layer)
	- IP 주소 지정과 데이터 패킷을 목적지까지 라우팅 하는 역할
	- 프로토콜: IP (주소 지정), ICMP (오류 처리)
- 네트워크 인터페이스 계층 (Network Interface Layer)
	- 물리적 네트워크 인터페이스와 직접 연결 (이더넷, Wi-Fi, MAC 주소)

**TCP/IP 모델과 OSI 7계층의 차이점**

| 구분             | OSI 7계층 | TCP/IP 4계층         |
| -------------- | ------- | ------------------ |
| 이론/실제          | 이론적 모델  | 실제 인터넷에서 사용        |
| 계층 수           | 7개      | 4개                 |
| 표현/세션 계층       | 따로 존재   | 응용 계층에 포함          |
| 데이터 링크 + 물리 계층 | 분리됨     | 네트워크 인터페이스 계층으로 통합 |


</div>
</details>

## 13. HTTP 프로토콜의 특징과 HTTP/1.1과 HTTP/2의 차이점을 설명해주세요.
- HTTP의 무상태(Stateless) 성질은 무엇이며, 어떻게 극복하나요?
- HTTP/2에서 추가된 주요 기능은 무엇인가요?
- HTTP/3에서 추가된 기능은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**HTTP 프로토콜의 특징**
- **Client - Sever 구조**
- **무상태 (Stateless)**: 서버에서 클라이언트의 상태를 저장하지 않는다.
	- 이를 해결하기 위해 **쿠키, 세션, JWT, 토큰 기반 인증** 등을 사용하여 상태 유지
- HTTP/1.0
	- **연결 하나당 요청 하나를 처리**하도록 설계되어 RTT 시간이 증가
		- 연결시마다 3-way handshake를 해주어야 했기 때문
- HTTP/1.1
	- HTTP/1.0에서 매번 요청시마다 연결을 해주는 방식에서 RTT 가 증가하는 문제를 해결하기 위해 TCP **연결을 재사용**하여 연결 1번에 요청을 여러 번 수행할 수 있게 되었다.
	- **HoL** (Head of Line) 이라는 병목 현상이 발생함.
		- HoL: 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하.
	- **무거운 헤더 구조**: 쿠키 등 많은 메타데이터가 들어있어 무거우나 압축이 되지 않아 무거움
- HTTP/2
	- **헤더 압축**: 무거운 헤더 구조를 개선하기 위해 허프만 인코딩으로 헤더 압축
	- **멀티플렉싱**: 여러 개의 스트림을 사용하여 송수신
		- 특정 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 끼치고 나머지는 정상 동작
	- 서버 푸시: HTTP/1.1에서는 클라이언트가 서버에 요청을 해야만 파일을 다운받을 수 있었으나, HTTP/2 에서는 **클라이언트 요청 없이 서버가 바로 리소스 푸시** 가능
- HTTP/3.0
	- UDP 기반 QUIC 프로토콜 사용: TCP의 3-way handshake 없이 1-RTT 연결 설정 하여 **더 빠른 연결 속도**
	- 개별 스트림 재전송: 패킷 손실 시 개별 스트림만 재전송하여 **속도 향상**
	- TCP 대신 UDP 기반으로 변경하여 HoL 블로킹을 제거함

</div>
</details>

## 14. TCP와 UDP의 특징과 차이점에 대해 설명해주세요.
- 연결 지향형 프로토콜과 비연결 지향형 프로토콜은 무엇인가요?
- TCP의 3-way handshake 과정은 어떻게 이루어지나요?
- 어떤 상황에서 UDP를 사용하는 것이 적합한가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**TCP**
- **연결 지향형(Connection-oriented) 프로토콜**
	- 통신 전에 3-way handshake를 통해 연결을 설정하고, 4-way handshake를 통해 연결을 해제함
- 신뢰성 보장
	- 패킷 손실 시 **재전송**(ACK, Timeout) 을 통해 보장
	- 순서 보장 (Sequencing): 패킷 순서가 뒤섞이지 않음
	- 흐름 제어 (Flow Control): 수신 측이 감당할 수 있는 속도로 데이터 전송 조절
	- 혼잡 제어 (Congestion Control): 네트워크 혼잡을 방지하기 위해 전송 속도를 조절 (패킷 로스로 확인)
- 3-way handshake
	- 클라이언트 -> 서버: SYN (연결 요청)
	- 서버 -> 클라이언트: SYN + ACK 전송 (요청 수락 및 응답)
	- 클라이언트 -> 서버: ACK (연결 확정)
- 4-way handshake
	- 클라이언트 -> 서버: FIN (연결 종료 요청)
	- 서버 -> 클라이언트: ACK (요청 확인)
	- 서버 -> 클라이언트: FIN (서버도 종료 요청)
	- 클라이언트 -> 서버: ACK (서버 종료 확인, 이후 연결 해제)
**UDP**
- **비연결 지향형(Connectionless) 프로토콜**
	- 핸드셰이크 과정 없이 데이터를 바로 전송
	- 신뢰성을 보장하지 않음 (순서 보장 X, 재전송 X)
- 빠른 속도
	- 패킷 손실을 감수하고 속도를 최우선
	- 작은 오버헤드 -> 실시간 통신에 적합
- 빠른 응답이 중요한 실시간 스트리밍, 온라인 게임, VoIP (e.g.Zoom)에 적합

</div>
</details>

## 15. 소켓 통신에 대해 설명해주세요.

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**소켓 통신**
- 소켓 통신은 **프로세스 간 네트워크 통신을 가능하게 하는 기술**
- 네트워크를 통해 **클라이언트와 서버 간 데이터를 주고 받는 방식**
- 소켓 통신 방식에는 TCP (연결 지향형), UDP (비연결 지향형)이 있다.
**Socket 이란?**
- **IP 주소 + 포트 번호**를 이용해 **네트워크 프로세스 간 데이터를 송수신하는 인터페이스**
- 운영체제에서 제공하는 API를 통해 사용 가능
- **TCP, UDP 기반의 네트워크 통신**에서 활용

**소켓 통신의 흐름**
![](https://i.imgur.com/iCfTNZP.png)
- 서버 측 과정
	1. 소켓 생성 (socket())
	2. 포트 바인딩 (bind())
	3. 연결 대기 (리스닝) (listen())
	4. 클라이언트 연결 수락 (accept())
	5. 데이터 송·수신 (recv(), send())
	6. 연결 종료 (close())
- 클라이언트 측 과정
	1. 소켓 생성 (socket())
	2. 서버에 연결 요청 (connect())
	3. 데이터 송·수신 (recv(), send())
	4. 연결 종료 (close())

</div>
</details>

### 관련 토의
HLS, XPC 관련한 질문들
- XPC는 소켓 통신인가?
  - XPCConnection은 양방향 프로세스 연결이다. 따라서 소켓 통신이다.
소켓통신의 사용 예시로는 실시간 스트리밍  서비스가 있다 -> HLS는 스트리밍 서비스를 지원하는 프레임워크 -> 소켓통신으로 사용될 수 있는가?


## 16. REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.
- iOS에서 URLSession을 사용하여 네트워크 요청을 보내는 방법은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**REST API란**
REST는 REpresentational State Transfer의 약자로 **자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것**을 의미합니다.
**REST의 특징**은 다음과 같습니다.
1. 서버-클라이언트 구조(Server-Client)
2. 무상태(Stateless)
3. 캐시 처리 가능 (Cacheable)
4. 계층화 (Layered System)
5. 인터페이스 일관성 (Uniform Interface)

즉 REST API란, 
1. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
2. HTTP Method(POST, GET, PUT, DELETE, PATCH 등) 를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미합니다.
REST API는 **REST의 원리를 따르는 API**를 의미합니다.
- 꼬리 질문
	- RESTFUL에 대해 설명해주세요.
		- RESTful이란 REST의 원칙을 **일관성 있게 적용하여 설계된 API**를 의미합니다.
		- 하지만 REST API를 사용했다고 하여 **모든 API가  RESTful 한 것은 아닙니다.**
		- RESTful 한 API를 설계하려면 
			- 적절한 HTTP Method 사용
			- 상태를 포함하지 않는 무상태 설계
			- 응답은 JSON, XML 등의 형태로 제공
		- 이러한 조건을 만족해야 합니다.
**iOS에서의 네트워크 요청 및 응답 처리 방법**
- iOS에서는 **URLSession**을 사용하여 네트워크 요청 및 응답을 처리합니다.
- 기본적으로 비동기 처리를 지원하며, 두 가지 방식으로 데이터를 요청하고 응답을 처리할 수 있습니다.

**Completion Handler 방식**
전통적으로 많이 사용되던 방식으로, **클로저를 사용하여 비동기 응답을 처리**합니다.

**async/await 방식 (iOS 15+)**
iOS 15 이상에서는 async/await을 사용하여 더욱 직관적으로 요청을 처리할 수 있습니다.

</div>
</details>

### 꼬리 질문 - REST란?
- REpresentational State Transfer의 약자. **자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것**을 의미

## 17. REST API에서 HTTP 메서드들의 차이점을 설명해주세요.
- GET과 POST의 차이점은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

- **GET**: 리소스 조회
	- 서버에 전달하고자 하는 데이터는 쿼리 스트링을 사용하여 전달.
	- URL에 데이터가 노출되어 보안성이 낮음
	- 캐싱 가능
- **POST**: 리소스 생성 및 데이터 처리
	- 멱등성이 성립하지 않음 (같은 요청을 여러 번 보내면 데이터 중복 생성 가능)
	- 서버에 전달할 데이터는 body에 json과 같은 형태로 전달
	- 데이터가 Body에 담겨 있기 때문에 노출 위험이 낮아 보안성이 GET 보다 좋음
	- 일반적으로 캐싱 불가능
- **PUT**: 리소스를 대체 (덮어쓰기, 완전 교체), 해당 리소스가 없으면 생성
- **DELETE**: 리소스 삭제
- **PATCH**: 리소스 부분 변경 (PUT은 전체 변경, PATCH는 일부 변경)
	- 멱등성이 성립하지 않을 수도 있음 (설계에 따라 달라짐)
	- e.g. 특정 리소스의 값을 10으로 만든다 => 멱등성 성립
	- 특정 리소스의 값을 10 증가시킨다. => 멱등성 성립하지 않음
- HEAD: GET과 동일하지만 메시지 부분 (body 부분)을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정

</div>
</details>

### 꼬리 질문 - 멱등성
- put과 patch의 차이점에 대해서
  - put은 **덮어쓰기**를 하여 매번 동일한 결과가 나온다.
  - patch는 구현하는 사람에 따라서 멱등성이 성립할 수도 있고 안할 수도 있다.
    - 값을 바꿔버리는 경우 (예: Person의 age를 21로 바꾼다.)는 멱등성이 성립
    - 값을 증감시키는 경우 (예: Person의 age를 1 증가시킨다.)는 멱등성이 성립하지 않는다.

## 18. HTTP 상태 코드에 대해서 설명해주세요.
- 1XX: 요청 진행중
- 2XX: 요청 정상 처리
- 3XX: 요청을 완료하려면 추가적인 행동이 필요
- 4xx (클라이언트 오류): 클라이언트의 잘못된 요청으로 인해 서버가 요청을 처리할 수 없음을 나타냄
- 5xx (서버 오류): 서버가 요청을 처리하는 중 오류가 발생했음을 나타냄

## 19. iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징에 대해 설명해주세요.
- PNG와 JPEG의 차이점은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**PNG**
- 비손실 압축: 압축 후에도 원본 품질 유지
- JPEG보다 용량이 크지만, 품질이 좋음
- 투명도 지원
**JPEG**
- 손실 압축: 이미지 압축 시 이미지의 데이터 일부 제거
- 높은 압축률
- 투명도 미지원
- 양자화 적용
**HEIC (High Efficiency Image File Format)**
- iOS 기본 이미지 포맷 (iOS 11 이후)
- JPEG보다 더 많은 저장공간 확보 가능
- HEVC (H.256) 압축 방식 사용
- 투명도 지원
- 라이선스 문제: 일부 플랫폼(Windows, 웹 등)에서는 기본 지원하지 않음, 호환성 부족

</div>
</details>

## 20. PNG 파일이 어떻게 저장되고 구성되는지 설명해주세요.

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

#### PNG 파일의 저장 방식 및 구성 요소
**PNG(portable Network Graphics)** 는 무손실 압축 방식으로 이미지를 구성하며, 파일 구조가 체계적으로 정의되어 있음
이 포맷은 이미지 데이터를 효율적으로 저장하고, 투명도(알파 채널)와 색상 정보를 정화기 표현할 수 있도록 설계됨
#### PNG 파일의 저장 방식
1. **무손실 압축**: Deflate 알고리즘을 사용하여 품질 저하 없이 용량을 줄임
2. **투명도 지원**: 알파 채널을 포함할 수 있어 배경이 투명한 이미지 저장 가능
3. **색상 모드**: 그레이스케일, RGB(Truecolor), 팔레트 기반 색상, 알파 채널 포함 가능
#### PNG 파일의 구성 요소
PNG 파일은 여러 개의 **청크(Chunk)** 들로 구성
- 파일 시그니처 (8바이트) -> 해당 파일이 PNG임을 나타냄, 항상 동일한 값
- 필수 청크
	- IHDR (Header) -> 이미지 크기, 색상 정보, 압축 방식 등 **기본 정보 저장**
	- IDAT (Image Data) -> **압축된 이미지 데이터**
	- IEND (End) -> 파일의 끝을 나타냄
- 선택적 청크
	- tEXt, zTXt, iTXt -> 메타데이터 (텍스트 설명, 키워드 등)
	- tRNS -> 일부 PNG에서 투명도 정보 제공
주요 청크(Chunk) 종류

| 청크                        | 설명                                 |
| ------------------------- | ---------------------------------- |
| IHDR (Header Chunk)       | 이미지의 크기, 컬러 타입, 필터 방식 등의 **기본 정보** |
| PLTE (Palette Chunk)      | 색상 팔레트 정보 (팔레트 기반 이미지에서 사용)        |
| IDAT (Image Data Chunk)   | 압축된 실제 이미지 데이터                     |
| IEND (End Chunk)          | PNG **파일의 끝**을 나타냄                 |
| tEXt, zTXt, iTXt          | 메타데이터 (텍스트 설명, 키워드 등)              |
| tRNS (Transparency Chunk) | 투명도 정보 (팔레트 기반 PNG에서 사용)           |
#### PNG의 주요 특징 요약
- 무손실 압축 방식으로 **품질을 유지하면서 파일 크기를 줄임**
- 투명도 지원
- 다양한 색상 모드 제공
- 압축 효율성이 뛰어나고, 이미지 데이터 외에도 메타데이터 저장 가능

</div>
</details>