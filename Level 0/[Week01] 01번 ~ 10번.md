## 01. 컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.
- CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?
- 버스(Bus)란 무엇이며, 어떤 종류가 있나요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

- **CPU**는 명령을 해석하고 연산을 수행하는 장치입니다.
- 주요 구성요소는 다음과 같습니다.
  - **ALU (산술논리연산장치)**: 덧셈, 뺄셈, 논리 연산 수행
  - **제어 장치 (Control Unit)**: 명령어를 해석하고 CPU 내부 장치 제어
  - **레지스터**: CPU 내부에서 직접 접근하는 **고속 임시 저장 공간**.
  - **캐시 메모리**: RAM 보다 빠른 메모리로, 자주 사용하는 데이터를 저장하여 성능 향상

- **메모리**
  - CPU가 처리할 데이터를 임시로 저장하는 고속 메모리
  - 휘발성 메모리
  - CPU가 실행할 프로그램과 데이터를 저장 장치에서 불러와 보관하는 역할
- **저장장치**
  - 데이터를 영구적으로 저장
  - 가장 속도가 느림
- **CPU와 메모리 간의 데이터 교환**
  - 버스(Bus)를 통해 이루어짐
  - 상호작용
    - 저장 장치에 있는 운영체제와 프로그램이 RAM에 올라감.
    - CPU는 램에 올라간 프로세스를 해석하여 실행
- **버스(Bus)**
  - 컴퓨터 내부에서 데이터, 주소, 제어 신호를 전달하는 통로
  - Bus의 종류
    - 주소 버스(Address Bus): CPU가 접근할 메모리 주소 전달
    - 데이터 버스(Data Bus): 실제 데이터 전송
    - 제어 버스(Control Bus): CPU가 제어 신호 전달
</div>
</details>


## 02. 캐시 메모리의 개념과 역할에 대해 설명해주세요.
- 캐시의 지역성(Locality) 원리에 대해 설명해주세요.

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

- **캐시**
  - 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- **지역성(Locality)**
  - 캐시에 저장할 자주 사용할 데이터에 대한 근거
    - 캐시 히트: CPU가 접근하려는 데이턱라 캐시에 존재하는 상태
    - 캐시 미스: CPU가 접근하려는 데이터가 캐시에 없어서 주 기억장치로부터 인출해와야 하는 상태
  - 지역성은 캐시 히트를 높이기 위한 것
  - 시간 지역성
    - 최근 사용한 데이터에 다시 접근하려는 특성
    - e.g. 반복문에서 1씩 증가하는 i
  - 공간 지역성
    - 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하려는 특성
    - e.g. 배열

### 꼬리 질문
**캐시의 계층 구조**
- 캐시는 L1, L2, L3 의 계층 구조를 가진다.
- 숫자가 작을 수록 빠르지만, 용량이 작고 비싸다.

</div>
</details>

## 03. CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.
<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">
- x86
	- Intel 기반 32bit CPU
	- 고성능
	- 개인용 컴퓨터와 서버에서 널리 사용됨
	- 상대적으로 전력 소모가 높아 모바일 기기에 부적합
- x86_64 (amd64)
	- Intel 기반 64 bit CPU, x86과 호환
- arm
    - arm이 개발한 전력 효율과 저전력 설계에 최적화된 RISC 기반 아키텍처
	- 저전력 소모가 특징으로 모바일과 같은 소형 기기에 적합
	- arm 기반 32bit CPU
	- x86과 달라 호환이 안됨
- arm64
	- arm 기반 64bit CPU
	- 32bit arm과 호환
</div>
</details>

## 04. iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.
- SoC(System on a Chip)의 개념은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">
**특징**
- 통합 설계: CPU, GPU, 메모리 컨트롤러, 모뎀 등 여러 기능을 하나의 칩에 통합하여 효율성을 높임. 이를 SoC 라고 한다.
  - 단일 칩 내에서 여러 기능을 수행하므로 공간 절약, 성능 최적화, 소비 전력 감소
- 고성능: 복잡한 애플리케이션과 멀티태스킹을 원활하게 처리 가능
- 저전력 설계: 모바일 기기의 배터리 수명을 고려하여 전력 효율성을 최적화 (고성능 코어와 저전력 코어를 적절히 분배하여 사용)
</div>
</details>

## 05. 운영체제의 역할과 iOS의 운영체제 구조에 대해 설명해주세요.
- iOS의 샌드박스 구조는 어떻게 동작하나요?
- 커널(Kernel)의 역할은 무엇인가요?
- 다중 태스킹(Multitasking)은 어떻게 지원되나요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**운영체제의 역할**
1. CPU 스케줄링 및 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할 지, 프로세스의 생성과 삭제, 리소스의 할당과 반환을 관리
2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마나 할당해야 하는 지 관리
3. 디스크 파일 관리: 디스크 파일을 어떤 방식으로 보관할지 관리
4. I/O 디바이스 관리: I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

**iOS의 운영체제 구조**
- iOS의 운영체제는 하위 계층부터 Core OS / Core Service / Media / Cocoa Touch / Application 으로 구성
  - 하위 계층으로 갈수록 하드웨어에 가깝고 기본이 되는 층이며, 상위로 갈수록 사용자와 관련이 있다.

**iOS의 샌드박스 구조**
- 각 앱이 독립된 환경에서 실행되도록 제한하여, 다른 앱이나 시스템 리소스에 접근하지 못하게 하고 다음을 보장함
  1. 격리된 파일 시스템: 앱은 자신만의 디렉토리에 접근 가능하며, 다른 앱의 데이터에 접근할 수 없음
  2. 네트워크 및 시스템 리소스 접근 제한: 앱이 특정 하드웨어 기능이나 네트워크 리소스를 사용하려면 권한이 필요
  3. 보안 강화를 위한 권한 관리: 실행중에도 사용자 승인을 요구하거나, 개발자가 미리 설정한 권한을 기반으로 동작
</div>
</details>

**커널의 역할**
운영체제의 핵심 구성 요소, 하드웨어와 소프트웨어 간의 중재자 역할
1. 프로세스 관리
   - 프로세스 생성, 스케줄링, 종료
   - CPU 시간을 효율적으로 분배
2. 메모리 관리
   - 물리적 메모리와 가상 메모리 관리
   - 메모리 접근 보호 및 주소 공간 할당
3. 장치 관리
   - I/O 장치와의 통신 제어
4. 파일 시스템 관리
   - 데이터를 디스크에 저장하고 검색
5. 보안 및 보호
   - 시스템 자원을 보호하고 사용자와 프로세스 권한 관리

**다중 태스킹 지원**
1. 백그라운드 실행 모드
  - 일부 앱은 백그라운드에서 특정 작업 수행 가능
2. GCD
  - 비동기 작업을 통해 UI의 반응성 유지
3. 스케줄링 및 우선순위 관리
  - CPU와 메모리를 효율적으로 사용하기 위해 작업의 우선순위를 설정
4. App Stats (앱 상태 관리)
  - iOS 앱 상태를 관리하여 리소스 낭비를 줄임

## 06. 프로세스와 스레드의 차이점, 그리고 iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.
- 멀티스레딩이 필요한 이유는 무엇인가요?
- iOS에서 GCD(Grand Central Dispatch)는 어떤 역할을 하나요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**프로세스**
- 실행중인 프로그램의 인스턴스
- 독립적인 메모리 공간 소유
- 프로세스 끼리 데이터를 공유하지 않음. 통신 시에는 IPC를 사용

**스레드**
- 프로세스 내부에서 실행되는 작업의 최소 단위
- 같은 프로세스 내 다른 스레드와 메모리 공유
- 스레드는 프로세스 내부에서 병렬적으로 실행가능

**멀티스레딩이 필요한 이유**
- 한 프로세스 내에서 시간이 오래 걸리는 작업이 존재할 때, 싱글 스레드를 사용하면 해당 작업이 끝날 때까지 **다른 작업이 대기**하게 된다. 특히 메인 스레드가 대기 상태가 되면 UI를 보여주는 작업이 멈추게 되어 사용자에게는 앱이 멈춘 것처럼 보이게 되어 사용자의 경험에 좋지 않다.
- 멀티스레딩을 사용하게 되면 UI는 메인 스레드에서 부드럽게 유지하면서도 무거운 작업은 백그라운드 스레드에서 병렬로 처리가 가능하다.

**iOS에서 GCD의 역할**
- GCD는 애플에서 제공하는 저수준의 C기반 API
- 개발자가 스레드 관리에 신경쓰지 않고 개발할 수 있도록 해줌
- **작업 큐(Dispatch Queue)**기반 동작, 개발자는 작업을 큐에 추가하기만 하면 GCD가 적절한 스레드에 작업을 배분
- 스레드 효율성: **스레드 풀**을 사용하여 불필요한 스레드 생성을 방지.
- 비동기 작업 처리

**꼬리 질문**: GCD vs. Operation
- GCD: 경량화된 API, 코드 블록을 큐에 추가하는 형식, 실행 우선순위 설정이 가능하지만 작업간 의존성 관리가 어려움
- Operation: 작업의 상태 추적 가능. 객체 지향적 방식(작업을 객체로 표현), 의존성, 취소, 재사용 가능

</div>
</details>

## 07. 메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.
- 자동 참조 카운팅(ARC)은 어떻게 동작하나요?
- Garbage Collection과의 차이는 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

- ARC를 사용하여 메모리 관리

**ARC 동작 원리**
- ARC는 힙 영역에 저장된 객체의 RC(참조 카운트)를 관리함
- 객체가 생성될 때 RC가 1로 설정되고, 해당 객체를 다른 객체가 참조할 때 1 증가, 참조가 해제되면 1 감소함
  - 구체적으로는 강한 참조(strong)의 경우 RC가 증감하고, 약한 참조(weak)와 미소유 참조(unowned)의 경우 RC가 증감하지 않음
- RC가 0이 되면 ARC가 메모리에서 해제함

**Garbage Collection과의 차이**
- Garbage Collection(이하 GC)은 주기적인 메모리 스캔을 통해 불필요한 객체를 정리하고 메모리에서 해제함.
- ARC는 참조 해제시 RC가 0이되면 즉각적으로 메모리에서 해제하지만, GC의 경우 메모리 해제 시점이 달라질 수 있음
</div>
</details>

## 08. iOS의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.
- URL 스킴(URL Scheme)을 이용한 앱 간 통신은 어떻게 이루어지나요?
- 앱 그룹(App Group)을 활용하여 데이터 공유를 하는 방법은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**iOS 샌드박스 개념과 역할**
- 각 앱이 독립된 환경(독립된 파일 시스템과 메모리 공간)에서 실행되도록 제한
- 앱 간 데이터 접근을 제한하여, 악의적인 앱이 다른 앱을 무단으로 읽거나 수정하지 못하게 함
- 각 앱은 고유한 컨테이너 디렉터리를 가지며, 이 디렉터리 외부의 데이터에 접근하기 위해서는 사용자에게 권한 요청을 받아야 함
- 각 앱이 독립된 환경에서 실행됨으로써 보안, 안정성, 프라이버시 보호를 강화할 수 있음

**앱 간 데이터 공유 방법**
- **URLScheme**
  - 한 앱이 다른 앱을 호출하거나 데이터를 전달할 수 있도록 하는 **커스텀 URL 프로토콜**
  - 호출하는 앱에서 custumScheme:// 의 형태로 호출
  - 호출받는 앱의 Info.plist에서 url scheme 등록
  - 호출받는 앱의 AppDelegate나 SceneDelegate에서 openURL 메서드로 URL 처리
- **App Group**
  - App Group: 같은 개발자가 만든 앱 간의 데이터 공유 기능
  - 프로젝트의 Capabilities에서 App Groups를 추가하여 활성화
  - UserDefaults 또는 FileManager, Core Data with App Group 등을 통해 데이터 공유 가능
</div>
</details>

## 09. iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.
- 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**iOS 메모리 구조**
- 코드, 데이터, 스택, 힙으로 구성
- 코드: 실행 바이너리가 저장되는 곳, 실행 도중 변경되지 않도록 Read-only
- 데이터: 전역 변수, static 변수가 저장. 실행 도중 변경이 가능하므로 Read-Write
- 스택
  - **함수 호출 시** 함수의 **지역 변수, 매개 변수, 리턴 값** 등이 저장. 함수가 종료되면 저장된 메모리도 **해제**
  - 스택 메모리의 크기는 컴파일 타임에 설정, 할당과 해제는 런타임에 이루어진다.
  - LIFO 구조
  - 지역 변수에만 액세스 가능
- 힙
  - 주로 (컴파일 타임에) 데이터의 크기를 알 수 없거나, 스택에 저장하기에 큰 데이터의 경우 할당되는 공간
  - 메모리를 사용 후 free를 해주어야 함. (iOS에서는 ARC가 관리)
  - 런타임에 할당
  - 변수에 접근하는 속도가 Stack보다 느림

**메모리 관리 방식**
Stack은 컴파일 타임에 결정되어 함수의 호출 시 할당되고, 함수가 종료되면 자동으로 메모리가 해제됨

Heap은 런타임에 할당되기 때문에 메모리 해제를 위해 ARC를 도입하여 사용
</div>
</details>

## 10. 네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.

<details>
<summary><strong>영균 대답</strong></summary>
<div markdown="1">

**네트워크 프로토콜 스택**
- 네트워크 통신을 효율적으로 처리하기 위해 계층화된 구조로 설계된 프로토콜의 집합
- 대표적으로 OSI 7계층과 TCP/IP 4계층이 존재

**iOS에서의 네트워크 통신 방식**
- URLSession
  - iOS의 기본 네트워킹 API
  - HTTP/HTTPS 요청을 보내고 응답을 처리할 수 있는 고수준의 API
  - 비동기 통신 지원 -> 백그라운드에서도 안정적인 요청 처리 가능
  - 다양한 작업 유형 지원: dataTask, downloadTask, uploadTask
- Network
  - iOS 12부터 도입된 저수준 네트워크 API
  - TCP/UDP 연결을 더 세밀하게 제어 가능
- Alamofire
  - URLSession의 복잡한 설정을 더 쉽게 괸리 가능하도록 도와주는 오픈소스 라이브러리
</div>
</details>